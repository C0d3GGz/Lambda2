type List {
  Cons(Int, List),
  Nil()
}

type Option {
  Some(Int),
  None()
}

let isEmpty: List -> Bool =
  \xs.
    match xs {
      List::Cons(a, b) => false,
      List::Nil() => true
    };

let head: List -> Option =
  \xs.
    match xs {
      List::Cons(h, t) => Option::Some(h),
      List::Nil() => Option::None()
    };

let tail: List -> List =
  \xs.
    match xs {
      List::Cons(h, t) => t,
      List::Nil() => List::Nil()
    };

let getOrElse: Int -> Option -> Int =
  \default. \opt.
    match opt {
      Option::Some(a) => a,
      Option::None() => default
    };

let map : (Int -> Int) -> List -> List =
  \f.
    let mapr =
      \mapr. \xs.
        match xs {
          List::Nil() => List::Nil(),
          List::Cons(h, t) => List::Cons(f h, mapr t)
        } in
    fix mapr;

let sum: Int -> Int =
  let sumr = \f. \x. if eq x 0 then 0 else add x (f (sub x 1)) in
  fix sumr;

let main: Int =
  let cons = \x. \xs. List::Cons(x, xs) in
  let l = cons 1 (cons 2 (cons 3 (cons 4 List::Nil()))) in
  getOrElse 42 (head (tail l));